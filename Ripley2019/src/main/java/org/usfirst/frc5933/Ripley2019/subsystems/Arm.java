// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5933.Ripley2019.subsystems;


import org.usfirst.frc5933.Ripley2019.Robot;
import org.usfirst.frc5933.Ripley2019.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Arm extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX armSubsystemMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	
	public static double kDown = 0.3 / 300 ; // target vBus proportional coefficient for moving the arm down. Should be positive.
	public static double kUp = 1.0 / 300; // target vBus proportional coefficient for moving the arm up. Should be positive.
	public static double vBusDownMax = -0.3; // probably don’t want to lower at top speed. Should be a negative number.
	public static double vBusUpMax = 1.0; // probably full power, positive
		// may want a vBusUpMin = 0.2 to make sure we always overcome gravity and static friction...
	public static boolean encoderPositioningUnderway = false; // true when the subsystem operator is holding one of the encoder position buttons (X, Y, A, whatever)
	public static int encoderTargetPosition = 0; // set when user hits an encoder-based desired position
	public static int bottomEncoder = 0, topEncoder = 1100; // values of the encoder whenever the lower or upper switch are triggered
	public static int rocketHatchOne = 73;
	public static int rocketHatchTwo = 656;
	public static int rocketHatchThree = 1119;

    public int blindCounter = 0;
    
    /**
	 * The ArmPositions correspond to absolute positions on an encoder
	 * feedback loop that the 'bot will score or get a cube from.
	 * The first three are all positions to acquire a cube, the next three
	 * are to score the cube, and Start should be used when in the pit
	 * and during disabled() to reset the arm for pit work and field setup. Continuous
	 * causes the arm to respond to a fluid set of inputs along its range.
	 */
	public enum ArmPosition {
		RocketHatchOne(73),
		RocketHatchTwo(656),
		RocketHatchThree(1119),
		Exchange(73),
		Start(0),
		Continuous(0),
		VBus(0);

		private final int pos;
		private ArmPosition(int encoderPos) {
			pos = encoderPos;
		}

		public int getPos() {
			return pos;
        }
    }

    public Arm() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		armSubsystemMotor = new WPI_TalonSRX(20);
		       
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    ArmPosition lastPos = ArmPosition.Start;

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
	}

        public void moveArm() {
            boolean lowerSwitch = Robot.roboRio.DIPs[0].get();
            boolean upperSwitch = Robot.roboRio.DIPs[1].get();
            double j = Robot.oi.subsystemJoystick.getY();
            if (!lowerSwitch) {
                if(j<0) {
                    armSubsystemMotor.stopMotor();
                }
                else{ 
                    armSubsystemMotor.set(j);
                }
            } 
             else if (!upperSwitch) {
                 if( j > 0) {
                    armSubsystemMotor.stopMotor();
                 }
                 else{ 
                    armSubsystemMotor.set(j);
                }
            } else {
                armSubsystemMotor.set(j);
            }
           
		}

        public void startEncoderPositioning(int desiredGoalPositioning) {
			int rocketOne = 1;
			int rocketTwo = 2;
			int rocketThree = 3;
			encoderPositioningUnderway = true;
			if (desiredGoalPositioning == rocketOne) {
				encoderTargetPosition = bottomEncoder + rocketHatchOne;
			} else if (desiredGoalPositioning == rocketTwo) {
				encoderTargetPosition = bottomEncoder + rocketHatchTwo;
			} else if (desiredGoalPositioning == rocketThree) {
				encoderTargetPosition = bottomEncoder + rocketHatchThree;
			} else {
				encoderPositioningUnderway = false;
			}
		}

		public void endEncoderPositioning() {
			encoderPositioningUnderway = false;
		}

        public void readArm() {
            SmartDashboard.putNumber("Arm Speed:", armSubsystemMotor.get());
        }

        public void readEncoder() {
            SmartDashboard.putNumber("Arm Encoder Pos: ", armSubsystemMotor.getSelectedSensorPosition());
        }

        public void stop(){
            armSubsystemMotor.stopMotor();
        }

        public void armUp(){
            armSubsystemMotor.set(0.7);
        }         

        public void armDown(){
            armSubsystemMotor.set(-0.7);
        }

    public void periodic() {
        // Put code here to be run every loop

        // readArm();
        readEncoder();

        //setArmFeedback(10);

		armSubsystemMotor.configForwardSoftLimitEnable(false, 10);
		armSubsystemMotor.configReverseSoftLimitEnable(false, 10);

		armSubsystemMotor.configNominalOutputForward(0, 10);
		armSubsystemMotor.configNominalOutputReverse(0, 10);
		armSubsystemMotor.configPeakOutputForward(0.2, 10);//armSubsystemMotor.configPeakOutputForward(1, 10);
		armSubsystemMotor.configPeakOutputReverse(-1, 10);
		
		armSubsystemMotor.configClosedloopRamp(0.5, 10); //seconds to full frontal val. Should help stop swinging. Could also use d-coeff.

		// Whenever a limit switch is active we want to reset the relevant 
			//one of these to the current encoder position
		boolean lowerSwitch = Robot.roboRio.DIPs[0].get(); 
		if ( !lowerSwitch) {
			bottomEncoder = armSubsystemMotor.getSelectedSensorPosition();
		}
		
		boolean upperSwitch = Robot.roboRio.DIPs[1].get();
		if (!upperSwitch) { 
			topEncoder = armSubsystemMotor.getSelectedSensorPosition();
		}

		// if subsystem driver has selected an encoder-based positioning button, perform it
		if (encoderPositioningUnderway) {
			int pos = armSubsystemMotor.getSelectedSensorPosition();
			int e = encoderTargetPosition - pos;
			double vBus = 0;
			if (e < 0) { 
				vBus = e * kDown; 
				if (vBus < vBusDownMax) { 
					vBus = vBusDownMax; 
				} // don’t lower too quickly 
				if (!lowerSwitch) { 
					vBus = 0; 
				} // just in case
			}  
			if (e >= 0) { 
				vBus = e * kUp; 
				if (vBus > vBusUpMax) {
					vBus = vBusUpMax; 
				} // can’t go faster than top speed
				if (!upperSwitch) { 
					vBus = 0; 
				} // just in case
			}
			armSubsystemMotor.set(vBus);
		} else { // otherwise subsystem driver is using the joystick
			moveArm(); // standard joystick-based arm movement
		}
	

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    public void resetEncoder() {
		armSubsystemMotor.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, 10);
        armSubsystemMotor.setSelectedSensorPosition(ArmPosition.Start.pos, 0, 10);
    }
}

